{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About RegExpInterpreter is an interpreter for the simple programming language designed to work with regular expressions. It also has a libraries for a work with quadtree-matrices and NFA. Last two modules can be used for developers. Interpreter has console interface for users.","title":"Home"},{"location":"#about","text":"RegExpInterpreter is an interpreter for the simple programming language designed to work with regular expressions. It also has a libraries for a work with quadtree-matrices and NFA. Last two modules can be used for developers. Interpreter has console interface for users.","title":"About"},{"location":"ATMLibrary/","text":"ATMLibrary ATMLibrary is a library used in Interpreter as main instrument to compute expressions and part of statements. NFA Type NFA consists of vals: StartState : HashSet FinalState : HashSet Transitions : IMatrix<Set<'t>> Functions epsClosure (nfa: NFA<_>) (algStr: AlgebraicStruct<'t>) (algStrForBoolOp: AlgebraicStruct<'t>) (matrixBuilder: int -> int -> (int -> int -> Set<_>) -> IMatrix<_>) - epsilon closure of ATM. intersect (fst: NFA<_>) (snd: NFA<_>) (algStr: AlgebraicStruct<'t>) (algStrForBoolOp: AlgebraicStruct<'t>) (matrixBuilder: int -> int -> (int -> int -> Set<_>) -> IMatrix<_>) - returns intersections of ATM's. toDot (this: NFA<_>) (outFile: string) - prints ATM to file regexpToNFA (regexp: Regexp<_>) (algStr: AlgebraicStruct<_>) (mtxBuilder: int -> int -> (int -> int -> HashSet<_>) -> IMatrix<HashSet<_>>) - converts regular expression to ATM. seqToNFA (input: list<_>) matrixBuilder - coverts string to ATM. accept (nfa: NFA<_>) (input: list<_>) (algStr: AlgebraicStruct<'t>) (algStrForBoolOp: AlgebraicStruct<'t>) (matrixBuilder: int -> int -> (int -> int -> Set<_>) -> IMatrix<_>) - return result of accepting string by ATM. findAll (nfa: NFA<_>) (input: list<_>) (algStr: AlgebraicStruct<'t>) (algStrForBoolOp: AlgebraicStruct<'t>) (matrixBuilder: int -> int -> (int -> int -> Set<_>) -> IMatrix<_>) - returns all searched substrings satisfying ATM.","title":"ATMLibrary"},{"location":"ATMLibrary/#atmlibrary","text":"ATMLibrary is a library used in Interpreter as main instrument to compute expressions and part of statements.","title":"ATMLibrary"},{"location":"ATMLibrary/#nfa","text":"","title":"NFA"},{"location":"ATMLibrary/#type","text":"NFA consists of vals: StartState : HashSet FinalState : HashSet Transitions : IMatrix<Set<'t>>","title":"Type"},{"location":"ATMLibrary/#functions","text":"epsClosure (nfa: NFA<_>) (algStr: AlgebraicStruct<'t>) (algStrForBoolOp: AlgebraicStruct<'t>) (matrixBuilder: int -> int -> (int -> int -> Set<_>) -> IMatrix<_>) - epsilon closure of ATM. intersect (fst: NFA<_>) (snd: NFA<_>) (algStr: AlgebraicStruct<'t>) (algStrForBoolOp: AlgebraicStruct<'t>) (matrixBuilder: int -> int -> (int -> int -> Set<_>) -> IMatrix<_>) - returns intersections of ATM's. toDot (this: NFA<_>) (outFile: string) - prints ATM to file regexpToNFA (regexp: Regexp<_>) (algStr: AlgebraicStruct<_>) (mtxBuilder: int -> int -> (int -> int -> HashSet<_>) -> IMatrix<HashSet<_>>) - converts regular expression to ATM. seqToNFA (input: list<_>) matrixBuilder - coverts string to ATM. accept (nfa: NFA<_>) (input: list<_>) (algStr: AlgebraicStruct<'t>) (algStrForBoolOp: AlgebraicStruct<'t>) (matrixBuilder: int -> int -> (int -> int -> Set<_>) -> IMatrix<_>) - return result of accepting string by ATM. findAll (nfa: NFA<_>) (input: list<_>) (algStr: AlgebraicStruct<'t>) (algStrForBoolOp: AlgebraicStruct<'t>) (matrixBuilder: int -> int -> (int -> int -> Set<_>) -> IMatrix<_>) - returns all searched substrings satisfying ATM.","title":"Functions"},{"location":"Installation/","text":"Installation You can install the package with dotnet by following this steps: Add a source and PAT in your nuget.config file (global or you can make local copy in project directory). dotnet nuget add source --username <YOUR_USERNAME> --password <PAT> --store-password-in-clear-text --name github \"https://nuget.pkg.github.com/alexander-kurdakov/index.json\" Install the package by using this command or do it in IDE Nuget manager. dotnet add PROJECT package RegExpInterpreter --version <version>","title":"Installation"},{"location":"Installation/#installation","text":"You can install the package with dotnet by following this steps: Add a source and PAT in your nuget.config file (global or you can make local copy in project directory).","title":"Installation"},{"location":"Installation/#_1","text":"dotnet nuget add source --username <YOUR_USERNAME> --password <PAT> --store-password-in-clear-text --name github \"https://nuget.pkg.github.com/alexander-kurdakov/index.json\" Install the package by using this command or do it in IDE Nuget manager.","title":""},{"location":"Installation/#_2","text":"dotnet add PROJECT package RegExpInterpreter --version <version>","title":""},{"location":"Interpreter/","text":"Interpreter Developers To interpret your code, at first you need to create an abstract syntax tree by using Interpreter.textToAST <string> . Then you can run the Interpreter.run <AST> to execute your program. Another functions processExpr (vDict: Dictionary<AST.VName, VType>) (expression: AST.Expr) - return a result of a given expression in VType format. processStmt (vDict: Dictionary<AST.VName, VType>) (stmt: AST.Stmt) - gets an expression from statement and sets it's value to the dictionary with variable as a key. Example let program = \" let [x] = (a|b)caba let [c] = isAcceptable \\\" acaba \\\" [x] let [d] = isAcceptable \\\" 1 \\\" (1*)&(1?) let [e] = findAll \\\" muxa \\\" (x|a) print [c] print [d] print [e]\" let ast = Interpreter . parseProgramToAST program Interpreter . run ast Given code prints True True [(2, 3);(3, 4)] into console. Users There are three console commands in RegExpInterpreter. --inputfile <file path> - the path to the file with code. --inputstring <string> - the string with code. --compute - returns the result of interpretation of the code","title":"Interpreter"},{"location":"Interpreter/#interpreter","text":"","title":"Interpreter"},{"location":"Interpreter/#developers","text":"To interpret your code, at first you need to create an abstract syntax tree by using Interpreter.textToAST <string> . Then you can run the Interpreter.run <AST> to execute your program.","title":"Developers"},{"location":"Interpreter/#another-functions","text":"processExpr (vDict: Dictionary<AST.VName, VType>) (expression: AST.Expr) - return a result of a given expression in VType format. processStmt (vDict: Dictionary<AST.VName, VType>) (stmt: AST.Stmt) - gets an expression from statement and sets it's value to the dictionary with variable as a key.","title":"Another functions"},{"location":"Interpreter/#example","text":"let program = \" let [x] = (a|b)caba let [c] = isAcceptable \\\" acaba \\\" [x] let [d] = isAcceptable \\\" 1 \\\" (1*)&(1?) let [e] = findAll \\\" muxa \\\" (x|a) print [c] print [d] print [e]\" let ast = Interpreter . parseProgramToAST program Interpreter . run ast Given code prints True True [(2, 3);(3, 4)] into console.","title":"Example"},{"location":"Interpreter/#users","text":"There are three console commands in RegExpInterpreter. --inputfile <file path> - the path to the file with code. --inputstring <string> - the string with code. --compute - returns the result of interpretation of the code","title":"Users"},{"location":"Language_guide/","text":"Language guide RegExpInterpreter uses simple programming language to work with regular expressions. Grammar Each regular expression is defined as variable which can be used in other expressions. Typical program consists of statements with expressions and variables' names associated with them. Statements There are three types of statements supported in the language: print [<vname>] let [<vname>] = <expression> printToDot [<vname>: RegExp] <string> print prints the regular expression corresponding to the given variable, let defines a variable and printToDot outputs regular expression in .dot format. <vname> starts with a Latin character, which can be followed by numbers or other letters. <expression> consists of Latin letters, digits, characters '-' '.' '/' '+' '~' ';' and other variables. As operators characters '(' ')' '*' '|' '?' '&' can be used. RegExp type RSmb of <char> RVar of <VName> Alt of <Regex * Regex> Seq of <Regex * Regex> Opt of <Regex> Star of <Regex> Intersect of <Regex * Regex> RVar case allows variables to be used inside regular expressions. Expressions RegExp of <Regex> FindAll of <string * Regex> IsAcceptable of <string * Regex> FindAll searches for all substrings satisfying the specified regular expression, IsAcceptable checks whether the string belongs to the specified expression. Operators Available operators in Interpreter-RegEx: * - Kleene star | - alternation ? - repeat 0 or 1 times & - intersect ( , ) - brackets for grouping Code example let [x] = (a|b)caba let [c] = isAcceptable \"acaba\" [x] let [d] = isAcceptable \"1\" (1*)&(1?) let [e] = findAll \"muxa\" (x|a) print [c] # True print [d] # True print [e] # [(2, 3); (3, 4)]","title":"Language guide"},{"location":"Language_guide/#language-guide","text":"RegExpInterpreter uses simple programming language to work with regular expressions.","title":"Language guide"},{"location":"Language_guide/#grammar","text":"Each regular expression is defined as variable which can be used in other expressions. Typical program consists of statements with expressions and variables' names associated with them.","title":"Grammar"},{"location":"Language_guide/#statements","text":"There are three types of statements supported in the language: print [<vname>] let [<vname>] = <expression> printToDot [<vname>: RegExp] <string> print prints the regular expression corresponding to the given variable, let defines a variable and printToDot outputs regular expression in .dot format. <vname> starts with a Latin character, which can be followed by numbers or other letters. <expression> consists of Latin letters, digits, characters '-' '.' '/' '+' '~' ';' and other variables. As operators characters '(' ')' '*' '|' '?' '&' can be used.","title":"Statements"},{"location":"Language_guide/#regexp-type","text":"RSmb of <char> RVar of <VName> Alt of <Regex * Regex> Seq of <Regex * Regex> Opt of <Regex> Star of <Regex> Intersect of <Regex * Regex> RVar case allows variables to be used inside regular expressions.","title":"RegExp type"},{"location":"Language_guide/#expressions","text":"RegExp of <Regex> FindAll of <string * Regex> IsAcceptable of <string * Regex> FindAll searches for all substrings satisfying the specified regular expression, IsAcceptable checks whether the string belongs to the specified expression.","title":"Expressions"},{"location":"Language_guide/#operators","text":"Available operators in Interpreter-RegEx: * - Kleene star | - alternation ? - repeat 0 or 1 times & - intersect ( , ) - brackets for grouping","title":"Operators"},{"location":"Language_guide/#code-example","text":"let [x] = (a|b)caba let [c] = isAcceptable \"acaba\" [x] let [d] = isAcceptable \"1\" (1*)&(1?) let [e] = findAll \"muxa\" (x|a) print [c] # True print [d] # True print [e] # [(2, 3); (3, 4)]","title":"Code example"},{"location":"QuadTree/","text":"QuadTree library QuadTree is a library used in Interpreter as automata transition type. QuadTree Type An instance of QuadTree<'t> is a discriminated union of: Node(QuadTree<'t>, QuadTree<'t>, QuadTree<'t>, QuadTree<'t>) Leaf<'t> None Functions member this.noneCheck (neutral: 't) - if this is (None, None, None, None) or Leaf(neutral) returns None , else return this . member this.plus (sndTree: quadTree<'t>) (algebraStruct: AlgebraicStruct<'t>) - sum of trees in specified algebraic structure. member this.reduce (need: int) (current: int) - resize of tree, allows to get rid of (None, None, None, _) . member this.scalarMultiply (scalar: 't) (multOp: 't -> 't -> 't) (neutral: 't) - multiplies to scalar each element of tree. ExtendedTree Type Extended tree is a QuadTree wrapper type that additionally contains size of tree. Consists of vals: colSize: int lineSize: int specSize: int tree: QuadTree<'t> Functions member this.toSparseMatrix - returns SparceMatrix equivalent. static member init (lineSize: int) (colSize:int) (func: int -> int -> 't) - initialize ExtendedTree. static member clearNeutral (neutral: int) (tree: extendedTree<'t>) - analog QuadTree.noneCheck member this.fillNeutral (neutral: 't) - All None to neutral member this.getByIndex (i:int) (j: int) (algStr: AlgebraicStruct<'t> - getter static member iteri (func: int -> int -> 't -> unit) (tree: extendedTree<'t>) - default iteri static member mapi (func: int -> int -> 't -> 'a) (exTree: extendedTree<'t>) - default mapi static member fold (func: 'a -> 't -> 'a) (acc: 'a) (tree: extendedTree<'t>) - default fold static member map (func: 't -> 'a) (exTree: extendedTree<'t>) - default map member this.plus (y: extendedTree<'t>) (algStruct: AlgebraicStruct<'t>) - sum of trees static member createTreeOfSparseMatrix (algStruct: AlgebraicStruct<'t>) (sparseMatrix: SparseMatrix<'t>) - create tree of SparseMatrix member this.multiply (snd: extendedTree<'t>) (algStruct: AlgebraicStruct<'t>) - matrices multiplying member this.tensorMultiply (snd: extendedTree<'t>) (algStruct: AlgebraicStruct<'t>) - matrices tensor multiplying member this.toBoolTree - return tree, where None -> false, 't -> true member this.transitiveClosure (algStruct: AlgebraicStruct<'t>) - transitive closure of matrix in algebraic struct. member this.parallelMultiply (snd: extendedTree<'t>) (algStruct: AlgebraicStruct<'t>) (depth: int) - parallel multiplying in 4^depth 'threads'. IMatrix interface ExtendedTree implements IMatrix interface: map: ('t -> 'a) -> IMatrix<'a> iteri: (int -> int -> 't -> unit) -> unit mapi: (int -> int -> 't -> 'a) -> IMatrix<'a> transitiveClosure: AlgebraicStruct<'t> -> IMatrix<'t> toBool: 't -> IMatrix<bool> fold: ('acc -> 't -> 'acc) -> 'acc -> 'acc get: int * int * AlgebraicStruct<'t> -> 't tensorMultiply: IMatrix<'t> -> AlgebraicStruct<'t> -> IMatrix<'t> lineSize: int colSize: int","title":"QuadTree library"},{"location":"QuadTree/#quadtree-library","text":"QuadTree is a library used in Interpreter as automata transition type.","title":"QuadTree library"},{"location":"QuadTree/#quadtree","text":"","title":"QuadTree"},{"location":"QuadTree/#type","text":"An instance of QuadTree<'t> is a discriminated union of: Node(QuadTree<'t>, QuadTree<'t>, QuadTree<'t>, QuadTree<'t>) Leaf<'t> None","title":"Type"},{"location":"QuadTree/#functions","text":"member this.noneCheck (neutral: 't) - if this is (None, None, None, None) or Leaf(neutral) returns None , else return this . member this.plus (sndTree: quadTree<'t>) (algebraStruct: AlgebraicStruct<'t>) - sum of trees in specified algebraic structure. member this.reduce (need: int) (current: int) - resize of tree, allows to get rid of (None, None, None, _) . member this.scalarMultiply (scalar: 't) (multOp: 't -> 't -> 't) (neutral: 't) - multiplies to scalar each element of tree.","title":"Functions"},{"location":"QuadTree/#extendedtree","text":"","title":"ExtendedTree"},{"location":"QuadTree/#type_1","text":"Extended tree is a QuadTree wrapper type that additionally contains size of tree. Consists of vals: colSize: int lineSize: int specSize: int tree: QuadTree<'t>","title":"Type"},{"location":"QuadTree/#functions_1","text":"member this.toSparseMatrix - returns SparceMatrix equivalent. static member init (lineSize: int) (colSize:int) (func: int -> int -> 't) - initialize ExtendedTree. static member clearNeutral (neutral: int) (tree: extendedTree<'t>) - analog QuadTree.noneCheck member this.fillNeutral (neutral: 't) - All None to neutral member this.getByIndex (i:int) (j: int) (algStr: AlgebraicStruct<'t> - getter static member iteri (func: int -> int -> 't -> unit) (tree: extendedTree<'t>) - default iteri static member mapi (func: int -> int -> 't -> 'a) (exTree: extendedTree<'t>) - default mapi static member fold (func: 'a -> 't -> 'a) (acc: 'a) (tree: extendedTree<'t>) - default fold static member map (func: 't -> 'a) (exTree: extendedTree<'t>) - default map member this.plus (y: extendedTree<'t>) (algStruct: AlgebraicStruct<'t>) - sum of trees static member createTreeOfSparseMatrix (algStruct: AlgebraicStruct<'t>) (sparseMatrix: SparseMatrix<'t>) - create tree of SparseMatrix member this.multiply (snd: extendedTree<'t>) (algStruct: AlgebraicStruct<'t>) - matrices multiplying member this.tensorMultiply (snd: extendedTree<'t>) (algStruct: AlgebraicStruct<'t>) - matrices tensor multiplying member this.toBoolTree - return tree, where None -> false, 't -> true member this.transitiveClosure (algStruct: AlgebraicStruct<'t>) - transitive closure of matrix in algebraic struct. member this.parallelMultiply (snd: extendedTree<'t>) (algStruct: AlgebraicStruct<'t>) (depth: int) - parallel multiplying in 4^depth 'threads'.","title":"Functions"},{"location":"QuadTree/#imatrix-interface","text":"ExtendedTree implements IMatrix interface: map: ('t -> 'a) -> IMatrix<'a> iteri: (int -> int -> 't -> unit) -> unit mapi: (int -> int -> 't -> 'a) -> IMatrix<'a> transitiveClosure: AlgebraicStruct<'t> -> IMatrix<'t> toBool: 't -> IMatrix<bool> fold: ('acc -> 't -> 'acc) -> 'acc -> 'acc get: int * int * AlgebraicStruct<'t> -> 't tensorMultiply: IMatrix<'t> -> AlgebraicStruct<'t> -> IMatrix<'t> lineSize: int colSize: int","title":"IMatrix interface"},{"location":"Structure/","text":"Github repository structure RegExpInterpreter \u251c\u2500\u2500 .config - dotnet tools config \u251c\u2500\u2500 .github - GitHub Actions setup \u251c\u2500\u2500 docs - documentation files \u251c\u2500\u2500 src - projects directory \u2502 \u251c\u2500\u2500 Interpreter - interpreter of regular expressions | \u251c\u2500\u2500 ATMLibrary - NFA library, can use quadtrees as transitions | \u2514\u2500\u2500 QuadTree - quadtrees library \u251c\u2500\u2500 tests | \u251c\u2500\u2500 Interpreter.Tests - tests for Interpreter | \u251c\u2500\u2500 QuadTree.Tests - tests for QuadTree | \u2514\u2500\u2500 ATMLibrary.Tests - tests for ATMLibrary \u251c\u2500\u2500 fsharplint.json - linter config \u251c\u2500\u2500 RegExpInterpreter.sln - solution file \u2514\u2500\u2500 build.fsx - configuration of build","title":"Github repository structure"},{"location":"Structure/#github-repository-structure","text":"RegExpInterpreter \u251c\u2500\u2500 .config - dotnet tools config \u251c\u2500\u2500 .github - GitHub Actions setup \u251c\u2500\u2500 docs - documentation files \u251c\u2500\u2500 src - projects directory \u2502 \u251c\u2500\u2500 Interpreter - interpreter of regular expressions | \u251c\u2500\u2500 ATMLibrary - NFA library, can use quadtrees as transitions | \u2514\u2500\u2500 QuadTree - quadtrees library \u251c\u2500\u2500 tests | \u251c\u2500\u2500 Interpreter.Tests - tests for Interpreter | \u251c\u2500\u2500 QuadTree.Tests - tests for QuadTree | \u2514\u2500\u2500 ATMLibrary.Tests - tests for ATMLibrary \u251c\u2500\u2500 fsharplint.json - linter config \u251c\u2500\u2500 RegExpInterpreter.sln - solution file \u2514\u2500\u2500 build.fsx - configuration of build","title":"Github repository structure"}]}